// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: nyct-subway.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TripReplacementPeriod: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The replacement period is for this route
  var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  /// The start time is omitted, the end time is currently now + 30 minutes for
  /// all routes of the A division
  var replacementPeriod: TransitRealtime_TimeRange {
    get {return _replacementPeriod ?? TransitRealtime_TimeRange()}
    set {_replacementPeriod = newValue}
  }
  /// Returns true if `replacementPeriod` has been explicitly set.
  var hasReplacementPeriod: Bool {return self._replacementPeriod != nil}
  /// Clears the value of `replacementPeriod`. Subsequent reads from it will return its default value.
  mutating func clearReplacementPeriod() {self._replacementPeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _routeID: String? = nil
  fileprivate var _replacementPeriod: TransitRealtime_TimeRange? = nil
}

/// NYCT Subway extensions for the feed header
struct NyctFeedHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the NYCT Subway extensions
  /// The current version is 1.0
  var nyctSubwayVersion: String {
    get {return _nyctSubwayVersion ?? String()}
    set {_nyctSubwayVersion = newValue}
  }
  /// Returns true if `nyctSubwayVersion` has been explicitly set.
  var hasNyctSubwayVersion: Bool {return self._nyctSubwayVersion != nil}
  /// Clears the value of `nyctSubwayVersion`. Subsequent reads from it will return its default value.
  mutating func clearNyctSubwayVersion() {self._nyctSubwayVersion = nil}

  /// For the NYCT Subway, the GTFS-realtime feed replaces any scheduled
  /// trip within the trip_replacement_period. 
  /// This feed is a full dataset, it contains all trips starting 
  /// in the trip_replacement_period. If a trip from the static GTFS is not
  /// found in the GTFS-realtime feed, it should be considered as cancelled.
  /// The replacement period can be different for each route, so here is 
  /// a list of the routes where the trips in the feed replace all 
  /// scheduled trips within the replacement period.
  var tripReplacementPeriod: [TripReplacementPeriod] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nyctSubwayVersion: String? = nil
}

/// NYCT Subway extensions for the trip descriptor
struct NyctTripDescriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nyct_train_id is meant for internal use only. It provides an
  /// easy way to associated GTFS-realtime trip identifiers with NYCT rail
  /// operations identifier 
  /// 
  /// The ATS office system assigns unique train identification (Train ID) to
  /// each train operating within or ready to enter the mainline of the
  /// monitored territory. An example of this is 06 0123+ PEL/BBR and is decoded
  /// as follows: 
  /// 
  /// The first character represents the trip type designator. 0 identifies a
  /// scheduled revenue trip. Other revenue trip values that are a result of a
  /// change to the base schedule include; [= reroute], [/ skip stop], [$ turn
  /// train] also known as shortly lined service.  
  /// 
  /// The second character 6 represents the trip line i.e. number 6 train The
  /// third set of characters identify the decoded origin time. The last
  /// character may be blank "on the whole minute" or + "30 seconds" 
  /// 
  /// Note: Origin times will not change when there is a trip type change.  This
  /// is followed by a three character "Origin Location" / "Destination
  /// Location"
  var trainID: String {
    get {return _trainID ?? String()}
    set {_trainID = newValue}
  }
  /// Returns true if `trainID` has been explicitly set.
  var hasTrainID: Bool {return self._trainID != nil}
  /// Clears the value of `trainID`. Subsequent reads from it will return its default value.
  mutating func clearTrainID() {self._trainID = nil}

  /// This trip has been assigned to a physical train. If true, this trip is
  /// already underway or most likely will depart shortly. 
  ///
  /// Train Assignment is a function of the Automatic Train Supervision (ATS)
  /// office system used by NYCT Rail Operations to monitor and track train
  /// movements. ATS provides the ability to "assign" the nyct_train_id
  /// attribute when a physical train is at its origin terminal. These assigned
  /// trips have the is_assigned field set in the TripDescriptor.
  ///
  /// When a train is at a terminal but has not been given a work program it is
  /// declared unassigned and is tagged as such. Unassigned trains can be moved
  /// to a storage location or assigned a nyct_train_id when a determination for
  /// service is made.
  var isAssigned: Bool {
    get {return _isAssigned ?? false}
    set {_isAssigned = newValue}
  }
  /// Returns true if `isAssigned` has been explicitly set.
  var hasIsAssigned: Bool {return self._isAssigned != nil}
  /// Clears the value of `isAssigned`. Subsequent reads from it will return its default value.
  mutating func clearIsAssigned() {self._isAssigned = nil}

  /// Uptown and Bronx-bound trains are moving NORTH.
  /// Times Square Shuttle to Grand Central is also northbound.
  ///
  /// Downtown and Brooklyn-bound trains are moving SOUTH.
  /// Times Square Shuttle to Times Square is also southbound.
  /// 
  /// EAST and WEST are not used currently.
  var direction: NyctTripDescriptor.Direction {
    get {return _direction ?? .north}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The direction the train is moving. 
  enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case north // = 1
    case east // = 2
    case south // = 3
    case west // = 4

    init() {
      self = .north
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .north
      case 2: self = .east
      case 3: self = .south
      case 4: self = .west
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .north: return 1
      case .east: return 2
      case .south: return 3
      case .west: return 4
      }
    }

  }

  init() {}

  fileprivate var _trainID: String? = nil
  fileprivate var _isAssigned: Bool? = nil
  fileprivate var _direction: NyctTripDescriptor.Direction? = nil
}

/// NYCT Subway extensions for the stop time update
struct NyctStopTimeUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provides the planned station arrival track. The following is the Manhattan
  /// track configurations:
  /// 1: southbound local
  /// 2: southbound express
  /// 3: northbound express
  /// 4: northbound local
  ///
  /// In the Bronx (except Dyre Ave line)
  /// M: bi-directional express (in the AM express to Manhattan, in the PM
  /// express away).
  ///
  /// The Dyre Ave line is configured:
  /// 1: southbound
  /// 2: northbound
  /// 3: bi-directional
  var scheduledTrack: String {
    get {return _scheduledTrack ?? String()}
    set {_scheduledTrack = newValue}
  }
  /// Returns true if `scheduledTrack` has been explicitly set.
  var hasScheduledTrack: Bool {return self._scheduledTrack != nil}
  /// Clears the value of `scheduledTrack`. Subsequent reads from it will return its default value.
  mutating func clearScheduledTrack() {self._scheduledTrack = nil}

  /// This is the actual track that the train is operating on and can be used to
  /// determine if a train is operating according to its current schedule
  /// (plan).
  /// 
  /// The actual track is known only shortly before the train reaches a station,
  /// typically not before it leaves the previous station. Therefore, the NYCT
  /// feed sets this field only for the first station of the remaining trip.
  /// 
  /// Different actual and scheduled track is the result of manually rerouting a
  /// train off it scheduled path.  When this occurs, prediction data may become
  /// unreliable since the train is no longer operating in accordance to its
  /// schedule.  The rules engine for the 'countdown' clocks will remove this
  /// train from all schedule stations.
  var actualTrack: String {
    get {return _actualTrack ?? String()}
    set {_actualTrack = newValue}
  }
  /// Returns true if `actualTrack` has been explicitly set.
  var hasActualTrack: Bool {return self._actualTrack != nil}
  /// Clears the value of `actualTrack`. Subsequent reads from it will return its default value.
  mutating func clearActualTrack() {self._actualTrack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scheduledTrack: String? = nil
  fileprivate var _actualTrack: String? = nil
}

// MARK: - Extension support defined in nyct-subway.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TransitRealtime_FeedHeader {

  var nyctFeedHeader: NyctFeedHeader {
    get {return getExtensionValue(ext: Extensions_nyct_feed_header) ?? NyctFeedHeader()}
    set {setExtensionValue(ext: Extensions_nyct_feed_header, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_feed_header`
  /// has been explicitly set.
  var hasNyctFeedHeader: Bool {
    return hasExtensionValue(ext: Extensions_nyct_feed_header)
  }
  /// Clears the value of extension `Extensions_nyct_feed_header`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctFeedHeader() {
    clearExtensionValue(ext: Extensions_nyct_feed_header)
  }
}

extension TransitRealtime_TripDescriptor {

  var nyctTripDescriptor: NyctTripDescriptor {
    get {return getExtensionValue(ext: Extensions_nyct_trip_descriptor) ?? NyctTripDescriptor()}
    set {setExtensionValue(ext: Extensions_nyct_trip_descriptor, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_trip_descriptor`
  /// has been explicitly set.
  var hasNyctTripDescriptor: Bool {
    return hasExtensionValue(ext: Extensions_nyct_trip_descriptor)
  }
  /// Clears the value of extension `Extensions_nyct_trip_descriptor`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctTripDescriptor() {
    clearExtensionValue(ext: Extensions_nyct_trip_descriptor)
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate {

  var nyctStopTimeUpdate: NyctStopTimeUpdate {
    get {return getExtensionValue(ext: Extensions_nyct_stop_time_update) ?? NyctStopTimeUpdate()}
    set {setExtensionValue(ext: Extensions_nyct_stop_time_update, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_stop_time_update`
  /// has been explicitly set.
  var hasNyctStopTimeUpdate: Bool {
    return hasExtensionValue(ext: Extensions_nyct_stop_time_update)
  }
  /// Clears the value of extension `Extensions_nyct_stop_time_update`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctStopTimeUpdate() {
    clearExtensionValue(ext: Extensions_nyct_stop_time_update)
  }

}

// MARK: - File's ExtensionMap: Nyct_u45Subway_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Nyct_u45Subway_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Extensions_nyct_feed_header,
  Extensions_nyct_trip_descriptor,
  Extensions_nyct_stop_time_update
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let Extensions_nyct_feed_header = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctFeedHeader>, TransitRealtime_FeedHeader>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_feed_header"
)

let Extensions_nyct_trip_descriptor = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctTripDescriptor>, TransitRealtime_TripDescriptor>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_trip_descriptor"
)

let Extensions_nyct_stop_time_update = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctStopTimeUpdate>, TransitRealtime_TripUpdate.StopTimeUpdate>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_stop_time_update"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension TripReplacementPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TripReplacementPeriod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_id"),
    2: .standard(proto: "replacement_period"),
  ]

  public var isInitialized: Bool {
    if let v = self._replacementPeriod, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._replacementPeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._replacementPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TripReplacementPeriod, rhs: TripReplacementPeriod) -> Bool {
    if lhs._routeID != rhs._routeID {return false}
    if lhs._replacementPeriod != rhs._replacementPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NyctFeedHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctFeedHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nyct_subway_version"),
    2: .standard(proto: "trip_replacement_period"),
  ]

  public var isInitialized: Bool {
    if self._nyctSubwayVersion == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tripReplacementPeriod) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nyctSubwayVersion) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tripReplacementPeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nyctSubwayVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.tripReplacementPeriod.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tripReplacementPeriod, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NyctFeedHeader, rhs: NyctFeedHeader) -> Bool {
    if lhs._nyctSubwayVersion != rhs._nyctSubwayVersion {return false}
    if lhs.tripReplacementPeriod != rhs.tripReplacementPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NyctTripDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctTripDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "train_id"),
    2: .standard(proto: "is_assigned"),
    3: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._trainID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isAssigned) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trainID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isAssigned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NyctTripDescriptor, rhs: NyctTripDescriptor) -> Bool {
    if lhs._trainID != rhs._trainID {return false}
    if lhs._isAssigned != rhs._isAssigned {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NyctTripDescriptor.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NORTH"),
    2: .same(proto: "EAST"),
    3: .same(proto: "SOUTH"),
    4: .same(proto: "WEST"),
  ]
}

extension NyctStopTimeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctStopTimeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scheduled_track"),
    2: .standard(proto: "actual_track"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._scheduledTrack) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._actualTrack) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scheduledTrack {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actualTrack {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NyctStopTimeUpdate, rhs: NyctStopTimeUpdate) -> Bool {
    if lhs._scheduledTrack != rhs._scheduledTrack {return false}
    if lhs._actualTrack != rhs._actualTrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
